#include <stdio.h>
#include <string.h>

int main() {
  //_EDID is a reserved name
  typedef char EDID_type;
  /*
  If use "\" to connect two lines, such as:
  _EDID EDID =
           "0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x10,0xAC,0xE5,0xD0,0x55,0x5A,0x4A,0x30,0x24,0x1D,0x01,\
       0x04,0xA5,0x3C,0x22,0x78,0xFB,0x6C,0xE5,0xA5,0x55,0x50,0xA0,0x23,0x0B,0x50,0x54,0x00,0x02,0x00,\
       0xD1,0xC0,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x58,0xE3,0x00,\
       0xA0,0xA0,0xA0,0x29,0x50,0x30,0x20,0x35,0x00,0x55,0x50,0x21,0x00,0x00,0x1A,0x00,0x00,0x00,0xFF,\
       0x00,0x37,0x4A,0x51,0x58,0x42,0x59,0x32,0x0A,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,0x00,\
       0x53,0x32,0x37,0x31,0x39,0x44,0x47,0x46,0x0A,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFD,0x00,0x28,\
       0x9B,0xFA,0xFA,0x40,0x01,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x2D";
    It will create some interval between two lines. The reason haven't been
  figured out yet.
  */
  // EDID_type EDID =
  //     "0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x10,0xAC,0xE5,0xD0,0x55,0x5A,"
  //     "0x4A,0x30,0x24,0x1D,0x01,0x04,0xA5,0x3C,0x22,0x78,0xFB,0x6C,0xE5,0xA5,"
  //     "0x55,0x50,0xA0,0x23,0x0B,0x50,0x54,0x00,0x02,0x00,0xD1,0xC0,0x01,0x01,"
  //     "0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x58,0xE3,"
  //     "0x00,0xA0,0xA0,0xA0,0x29,0x50,0x30,0x20,0x35,0x00,0x55,0x50,0x21,0x00,"
  //     "0x00,0x1A,0x00,0x00,0x00,0xFF,0x00,0x37,0x4A,0x51,0x58,0x42,0x59,0x32,"
  //     "0x0A,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,0x00,0x52,0x50,0x30,"
  //     "0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x00,0x00,0x00,0xFD,"
  //     "0x00,0x28,0x9B,0xFA,0xFA,0x40,0x01,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,"
  //     "0x00,";

  // // Try to use another way to input EDID(terminal input)
  // EDID_type EDID[635] = "";
  // char readBuffer[1] = "";

  // // If EDID[634] == '\0', continue to read input
  // while (EDID[633] == '\0') {
  //   scanf("%s", readBuffer);
  //   strcat(EDID, readBuffer);
  //   //Empety readBuffer
  //   memset(readBuffer, 0, sizeof(readBuffer));
  // }
  // Failed, try to read byte by byte
  EDID_type EDID[635] = "";
  char ch = '\0';
  // Make p point to the start of EDID
  char *p = EDID;
  //Think another way to break the loop
  while (EDID[633] == '\0') {
    ch = getchar();
    if ((('0' <= ch) && (ch <= '9')) || (('A' <= ch) && (ch <= 'Z')) ||
        ch == ',' || (('a' <= ch) && (ch <= 'z'))) {
      *p = ch;
      ++p;
    }
  }

  // Let p point to the head of EDID again
  p = EDID;

  // Initiate every element of the array to '\n'
  char praseBuffer[5] = "";
  int sum = 0;
  // Make the buffer[0] to \0(initiate)
  // buffer[0] = '\0';
  int value = 0;
  while (*p) {
    // Write a byte of EDID(string) into buffer
    for (int i = 0; *p != ',' && *p != '\0'; ++p) {
      praseBuffer[i] = *p;
      ++i;
    }
    // Convert string to value by using function "sscanf"
    sscanf(praseBuffer, "%x", &value);
    sum += value;
    // Without this "if", p will point to the memory out of the EDID string
    if (*p == '\0') {
      break;
    }
    ++p;
  }

  printf("sum:%x\n", sum);

  // Generate the checksum automatically
  // In my environment, type "int" is 4 byte wide(AKA 32 bits)
  int cheksum = 0;
  //(sum ^ 0x00FF) gets the reverse of the lower 8 bits of sum, but the higher
  // 8 bits still needs to be deal. & 0x00FF make the higher 8 bits to 0x00.
  // Finally + 1, made sum's lower 8 bits plus checksum equals to 256(AKA sum +
  // checksum mod 256)
  //注意运算顺序，((sum ^ 0x00FF) & 0x00FF + 1 会先算 0x00FF +
  // 1，导致最后与上0x0100，得到错误结果。
  cheksum = ((sum ^ 0x00FF) & 0x00FF) + 1;
  printf("checksum:%x\n", cheksum);

  return 0;
}